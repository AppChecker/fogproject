#!/bin/bash

# SCRIPT NAME: fog.upload
# SCRIPT DESCRIPTION: Uploads image found on the client to the server

### BEGIN FUNCTION INCLUDES
if [ -z "$FUNCS_SH" ]; then
	. /usr/share/fog/lib/funcs.sh;
fi
if [ -z "$UI_SH" ]; then
	. /usr/share/fog/lib/ui.sh
fi
. /bin/fog.checkin
### END FUNCTION INCLUDES

### BEGIN VARIABLES
imagePath="/images/$macWinSafe"
percent=$pct
### END VARIABLES

### BEGIN FUNCTIONS
# Update the percentage variable in case of strange cases
# No arguments expected
function updatePercent() {
	if [ $percent -lt 5 ] || [ $percent -ge 100 ]; then
	    percent=5
	fi
	if [ $percent -lt 10 ]; then
	    percent="0$percent"
	fi
}

# Prepare the destination
# No arguments expected
function prepareDestination(){
	mkdir -p "$imagePath"
	# TODO - Ditch 777
	chmod -R 777 $imagePath
	rm -Rf "$imagePath/*"
}

# Expects an NTFS partition
# $1 is the partition to check [Required]
# Return codes
# 0: Unrecogized NTFS
# 1: Windows Boot Partition
# 2: Windows System Partition
# 3: Windows Recovery Parition [Unimplemented]
function chkWinPart() {
	local winPart="$1"
	local rCode=0
	dots "Mounting $winPart readonly"
	mkdir /ntfs &>/dev/null
	mount -o ro $winPart 2>/dev/null
	if [ -f "/ntfs/bootmgr" ]; then
		rCode=1
	else [ -f "/ntfs/pagefile.sys" ] || [ -f "/ntfs/hyberfil.sys" ]; then
		rCode=2
	fi

	dots "Unmounting $winPart"
	umount $winPart 2>/dev/null

	return rCode
}

# Expects an NTFS partition
# $1 is the partition to check [Required]
# Deletes page file and hiberfil.sys from partition
function remPageFile() {
	local winPart="$1"
	dots "Mounting $winPart read-write"
	mkdir /ntfs &>/dev/null
	mount -o rw $winPart 2>/dev/null
	dots "Removing pagefile.sys"
	if [ -f "/ntfs/pagefile.sys" ]; then
		rm -f "/ntfs/pagefile.sys" >/dev/null 2>&1
	fi
	dots "Removing hiberfil.sys"
	if [ -f "/ntfs/hyberfil.sys" ]; then
		rm -f "/ntfs/hiberfil.sys" >/dev/null 2>&1
	fi

	dots "Unmounting $winPart"
	umount $winPart 2>/dev/null
}

# This processes a resizable imaging job
# No arguments expected
function adjstPartSave() {
	part=""
	fixed_size_partitions=""

	# Find fixed-size partitions based on fstype
	partList=`fogpartinfo --list-parts $hd 2>/dev/null`
	for part in partList; do
		fstype=`fsTypeSetting $part`
		if [ "$fstype" == "extfs" ]; then
			extfsavail=`expr $extfsavail '+' 1`
		elif [ "$fstype" == "ntfs" ]; then
			win7partcnt=`expr $win7partcnt '+' 1`
			ntfsType=`chkWinPart`
			# Windows Boot Partition
			if [ "$ntfsType" == "1" ]; then
				fixed_size_partitions="${fixed_size_partitions}:$part"
			# Windows System Partition - Delete PageFile.sys/Hiberfil.sys
			elif [ "$ntfsType" == "2" ] && [ "$ignorepg" == "1" ]; then
				remPageFile $part
			fi
			# TODO Make Windows Recovery partition fixed
		else
			fixed_size_partitions="${fixed_size_partitions}:$part"
		fi
	done

	# Only save partition numbers
	fixed_size_partitions=`echo $fixed_size_partitions | sed 's/[^:0-9]\|^:/g'`
	echo $fixed_size_partitions > "${imagePath}/d1.fixed_size_partitions"
	
	# NOTE: By this phase in the original version of this script, it made sure
	#       XP started at sector 63. I assume that no one is running XP SP1.

	# Clear partition data as a precaution
	echo -n "" > "${imagePath}/d1.original.fstypes"
	echo -n "" > "${imagePath}/d1.original.swapuuids"
	debugPause
	
	# Shrink partitions before cloning
	for part in $partList; do
		shrinkPartition "$part" "${imagePath}/d1.original.fstypes"
	done
	runPartProbe $hd
	gptorMBRSave "$hd" "$imagePath"
	debugPause

	echo -e "\n * Now FOG will attempt to upload the image using Partclone.\n"
	
	# Clone partitions
	diskLength=`expr length $hd`
	for part in $partList; do
		mkfifo /tmp/pigz1
		partNum=${part:$diskLength}
		echo " * Processing Partition: $part ($partNum)"
		fstype=`fsTypeSetting $part`
		if [ "$fstype" != "swap" ]; then
			# Reset flag on NTFS partitions
			if [ "$fstype" == "ntfs" ]; then
				resetFlag "$part"
			fi
			echo " * Using partclone.${fstype}"
			sleep 5
			imgpart="$imagePath/d1p${partNum}.img"
			uploadFormat "$cores" "/tmp/pigz1" "$imgpart"
			partclone.$fstype -c -s $part -O /tmp/pigz1 -N -f 1 2>/tmp/status.fog
			mv $imgpart.000 $imgpart 2>/dev/null
			clear
			echo " * Image uploaded"
		else
			echo " * Not uploading swap partition"
			saveSwapUUID "${imagePath}/d1.original.swapuuids" "$part"
		fi
		rm /tmp/pigz1
		debugPause
	done
	dots "Restoring MBR"
	applySfdiskPartitions "${hd}" "${imagePath}/d1.original.partitions"
	fdisk $hd &>/dev/null << EOFRESTOREPART
w
EOFRESTOREPART
	echo "Done"
	debugPause

	# Apply Vista fix if needed
	if [ "$osid" == "2" ]; then
		correctVistaMBR $hd
	fi
	debugPause

	# Expand partitions to normal
	for part in $partList; do
		expandPartition "$part"
	done
}

# This processes a Multiple Partition Single Disk job
# No arguments expected
function mpsPartSave() {
	hasgpt=`hasGPT $hd`
	if [ "$hasgpt" == "0" ]; then
		have_extended_partition=`sfdisk -l $hd 2>/dev/null \
			| egrep "^${hd}.*(Extended|W95 Ext'd \(LBA\))$" | wc -l`
	else
		have_extended_partition="0"
	fi
	if [ ! -d "$imagePath" ]; then
		handleError "Unable to create $imagePath"
	else
		savePartitionTablesAndBootLoaders "$hd" "1" "$imagePath" "$osid" "$hasgpt" "$have_extended_partition" "$imgPartitionType"
		debugPause
		partList=`fogpartinfo --list-parts $hd 2>/dev/null`
		diskLength=`expr length $hd`
		for part in $partList; do
			savePartition "$part" "1" "$imagePath" "$diskLength" "$cores" "$imgPartitionType"
			debugPause
		done
		echo " * Task complete!"
	fi
}

# This processes a Multiple Partition All Disks job
# No arguments expected
function mpaPartSave() {
	diskList=`fogpartinfo --list-devices 2>/dev/null`
	intDisk=1
	for disk in $diskList; do
	echo " * Processing Hard Disk: $disk"
	hasgpt=`hasGPT $disk`
	if [ "$hasgpt" == "0" ]; then
		have_extended_partition=`sfdisk -l $disk 2>/dev/null \
			| egrep "^${disk}.*(Extended|W95 Ext'd \(LBA\))$" | wc -l`
	else
		have_extended_partition="0";
	fi
	if [ ! -d "$imagePath" ]; then
		handleError "Unable to create $imagePath";
	else
		savePartitionTablesAndBootLoaders "$disk" "$intDisk" "$imagePath" "$osid" "$hasgpt" "$have_extended_partition" "$imgPartitionType"
		debugPause
		partList=`fogpartinfo --list-parts $disk 2>/dev/null`;
		diskLength=`expr length $disk`;
		for part in $parts; do
			savePartition "$part" "$intDisk" "$imagePath" "$diskLength" "$cores" "$imgPartitionType"
			debugPause;
		done
	fi
	echo " * Disk $disk complete!";
	intDisk=`expr $intDisk '+' 1`;
	debugPause;
	done
}

# This processes a Raw Partition job
# No arguments expected
function rawDiskSave() {
	imgpart="${imagePath}/$img"
	mkfifo /tmp/pigz1
	uploadFormat "$cores" "/tmp/pigz1" "$imgpart"
	partclone.imager -c -s $hd -O /tmp/pigz1 -N -f 1 2>/tmp/status.fog
	rm /tmp/pigz1
	clear
}

# This sends the final signals back to the server at the end of the job
# No arguments expected
function sendEndJob() {
	queueinfo="";
	if [[ "$osid" == +([5-7]|9) ]]; then
		imgType="mps"
	fi
	post="http://${web}service/Post_Stage2.php?to=$img&mac=$mac&ftp=$ftp&size=$size&imgid=$imgid&imgtype=$imgType&osid=$osid&type=$type"
	queueinfo=`wget -q -O - "$post" 2>/dev/null`
	while [ "$queueinfo" != "##" ]; do
		echo "      * $queueinfo"
		queueinfo=`wget -q -O - "$post" 2>/dev/null`
		sleep 5
	done
}

### END FUNCTIONS

updatePercent

fog.statusreporter "$mac" "$web" &
if [ ! -f "/images/.mntcheck" ]; then
	handleError "Fatal Error: Failed to mount NFS Volume."
elif [ -z "$img" ]; then
	handleError "Fatal Error: Invalid image name."
else
	debugPause
	echo -e " * Saving image ${img} at ${imagePath}\n"
	prepareDestintation
	dots "Looking for Hard Disk"
	getHardDisk
	echo "Done"

	if [ -z "$hd" ]; then
		handleError "No hard disk found!"
	fi
	debugPause

	# Resizable Partition Image Type
	if [ "$imgType" == "n" ]; then
		adjstPartSave
	# Multiple Partition - Single Disk
	elif [ "$imgType" == "mps" ]; then
		mpsPartSave
	# Multiple Partition - All Disks
	elif [ "$imgType" == "mpa" ]; then
		mpaPartSave
	# Raw Image
	else
		rawDiskSave
	fi
	# TODO - Ditch 777
	# Fix permissions on the image directory
	chmod -R 777 $imagePath
	sendEndJob
fi
