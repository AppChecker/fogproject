#!/bin/bash

# SCRIPT NAME: fog.download
# SCRIPT DESCRIPTION: Downloads image from server to the client

### BEGIN FUNCTION INCLUDES
if [ -z "$FUNCS_SH" ]; then
	. /usr/share/fog/lib/funcs.sh;
fi
if [ -z "$UI_SH" ]; then
	. /usr/share/fog/lib/ui.sh
fi

. /bin/fog.donate;
. /bin/fog.checkin;
### BEGIN FUNCTION INCLUDES

### BEGIN VARIABLES
layPartSize="-1s"
imagePath="/images/$img"
fog.statusreporter "$mac" "$web" &
statusReporter="$!"
fixed_size_partitions=""
### END VARIABLES

### BEGIN FUNCTIONS
function nfsFail() {
	local nfsErrorMsg="Fatal Error: Failed to mount NFS Volume at /images.\n"
	nfsErrorMsg="${nfsErrorMsg} * If you believe the filesystem is mounted,\n"
	nfsErrorMsg="${nfsErrorMsg}   make sure you have a file called .mntcheck\n"
	nfsErrorMsg="${nfsErrorMsg}   in the directory you are mounting on the server"
	handleError "$nfsErrorMsg"
}

# TODO - Clean-up
function adjstPartBuild() {
	validResizeOS
	enableWriteCache "$hd"
	part="${hd}1"
	win7partcnt="0"
	win7rec=""
	win7sys=""
	if [ -f "$win7imgroot/sys.img.000" ] || \
		grep -q "sys.img.000" /tmp/filelist.txt &>/dev/null; then
		# Windows Vista+
		if [[ "$osid" == +([5-7]|9) ]]; then
			dots "Windows Boot Partition Exists"
			if [ -f "$win7imgroot/rec.img.000" ] || \
				grep -q "rec.img.000" /tmp/filelist.txt &>/dev/null; then
				echo "Yes"
				win7partcnt="2"
				win7rec="${hd}1"
				win7sys="${hd}2"
				part=$win7sys
				downloadPartition="${hd}3"
				partCount="2"
				downloadPartitionCount="3"
			elif [ -f "$win7imgroot/gpt.bak" ] || \
				grep -q "gpt.bak" /tmp/filelist.txt &>/dev/null; then
				echo "Yes"
				win7partcnt="3"
				win7rec="gpt"
				win7sys="${hd}3"
				part=$win7sys
				downloadPartition="${hd}4"
				partCount="3"
				downloadPartitionCount="4"
			else
				echo "No"
				win7partcnt="1"
				win7sys="${hd}1"
				downloadPartition="${hd}2"
				partCount="1"
				downloadPartitionCount="2"
			fi
		fi
		debugPause;
		dots "Preparing Hard Disks (Stage 1)"
		if [ "$nombr" == "1" ]; then
			echo "Skipped"
		else
			dd if=/dev/zero of=$hd bs=512 count=20 &>/dev/null
			parted -s $hd mktable msdos &>/dev/null
			dd if=$mbrfile of=$hd bs=512 count=1 &>/dev/null
			runPartprobe "$hd"
			echo "Done"
		fi
		debugPause
		diskSize=`parted -s $hd u kB print | awk -F'[: ]+' /Disk\ \\//'{print $3+0}'`
		if [ "$diskSize" -gt 2199023256 ]; then
			layPartSize="2tB"
		fi
		if [ "$win7partcnt" == "1" ]; then
			dots "Preparing Hard Disks (Stage 2)"
			parted -s $hd rm 1 &>/dev/null
			echo "Done"
			debugPause
			dots "Preparing Hard Disks (Stage 3)"
			if [ -r "${imagePath}/d1.original.partitions" ]; then
				if [ -r "${imagePath}/d1.fixed_size_partitions" ]; then
					fixed_size_partitions=`cat ${imagePath}/d1.fixed_size_partitions`
				fi
				fillDiskWithPartitions "${hd}" "${imagePath}/d1.original.partitions" "${fixed_size_partitions}"
			elif [ "$imgFormat" == "1" -o "$imgLegacy" == "1" ]; then
				parted -s $hd mkpart primary ntfs 63s -- $layPartSize &>/dev/null
			else
				parted -s $hd -a opt mkpart primary ntfs 2048s -- $layPartSize &>/dev/null
			fi
			parted -s $hd set 1 boot on &>/dev/null
		elif [ "$win7partcnt" == "2" ]; then
			dots "Preparing Hard Disks (Stage 2)"
			parted -s $hd rm 2 &>/dev/null
			echo "Done"
			debugPause
			dots "Preparing Hard Disks (Stage 3)"
			if [ -r "${imagePath}/d1.original.partitions" ]; then
				if [ -r "${imagePath}/d1.fixed_size_partitions" ]; then
					fixed_size_partitions=`cat ${imagePath}/d1.fixed_size_partitions`
				fi
				fillDiskWithPartitions "${hd}" "${imagePath}/d1.original.partitions" "${fixed_size_partitions}"
			else
				parted -s $hd -a opt mkpart primary ntfs $defaultpart2start -- $layPartSize &>/dev/null
			fi
		elif [ "$win7partcnt" == "3" ]; then
			dots "Preparing Hard Disks (Stage 2)"
			sgdisk --zap-all $hd 2>&1 >/dev/null
			sgdisk --mbrtogpt --load-backup=$win7imgroot/gpt.bak --move-second-header $hd &>/dev/null
			echo "Done"
			debugPause
			dots "Preparing Hard Disks (Stage 3)"
			sgdisk -x 3:$(sgdisk -E $hd) $hd &>/dev/null
		elif [ "$win7partcnt" == "4" ]; then
			dots "Preparing Hard Disks (Stage 2)"
			sgdisk --zap-all $hd 2>&1 >/dev/null
			sgdisk --mbrtogpt --load-backup=$win7imgroot/gpt.bak --move-second-header $hd &>/dev/null
			echo "Done"
			debugPause
			dots "Preparing Hard Disks (Stage 3)"
			sgdisk -x 4:$(sgdisk -E $hd) $hd &>/dev/null
		fi
		runPartprobe $hd
		echo "Done"
		debugPause
	elif [ -f "$imagePath" -o -f "$imagePath/$img" ] && [[ "$osid" == +([1-2]) ]];then
		if [ -d "$imagePath" ]; then
			imagePath="$imagePath/$img"
		fi
		dots "Preparing Hard Disks (Stage 2)"
		parted -s $hd rm 1 &>/dev/null
		echo "Done"
		debugPause
		dots "Preparing hard Disks (Stage 3)"
		parted -s $hd mkpart primary ntfs 63s -- $layPartSize &>/dev/null
		parted -s $hd set 1 boot on &>/dev/null
		runPartprobe $hd
		echo "Done"
		debugPause
	# Linux:
	#  restore MBR/GRUB
	#  resize original partition table to current disk, and apply it
	elif [[ "$osid" == +([1-2]|[5-7]|9|50) ]]; then
		restorePartitionTablesAndBootLoaders "$hd" "1" "$imagePath" "$osid" "$imgPartitionType"
		dots "Expanding partition table to fill disk"
		if [ -r "${imagePath}/d1.fixed_size_partitions" ]; then
			fixed_size_partitions=`cat ${imagePath}/d1.fixed_size_partitions`
		fi
		fillDiskWithPartitions "${hd}" "${imagePath}/d1.original.partitions" "${fixed_size_partitions}"
		runPartprobe $hd
		echo "Done"
		debugPause
	fi
	sleep 3
}

# TODO - Clean-up
function mpsPartBuild() {
	if [ ! -d "$imagePath" ]; then
		handleError "Unable to locate image store."
	else
		restorePartitionTablesAndBootLoaders "$hd" "1" "$imagePath" "$osid" "$imgPartitionType"
		gptcheck="$global_gptcheck"
	fi
}

# TODO - Clean-up
function mpaPartBuild() {
	disks=`fogpartinfo --list-devices 2>/dev/null`
	intDisk=1
	if [ ! -d "$imagePath" ]; then
		handleError "Unable to locate image store."
	else
		for disk in $disks; do
			restorePartitionTablesAndBootLoaders "$disk" "$intDisk" "$imagePath" "$osid" "$imgPartitionType"
			gptcheck="$global_gptcheck"
			intDisk=`expr $intDisk '+' 1`
		done
	fi
}

# TODO - Clean-up
function adjstPartDeploy() {
	parts=`fogpartinfo --list-parts $hd 2>/dev/null`
	diskLength=`expr length $hd`
	if [ -f "$win7imgroot/sys.img.000" ] && [[ "$osid" == +([5-7]|9) ]]; then
		if [ "$win7partcnt" == "1" ]; then
			restorePartition "$win7sys"
		elif [ "$win7partcnt" == "2" ]; then
			restorePartition "$win7rec"
			restorePartition "$win7sys"
		elif [ "$win7partcnt" == "3" ]; then
			restorePartition "${hd}1"
			restorePartition "${hd}2"
			restorePartition "$win7sys"
		fi
	elif [ -f "$imagePath" ] && [[ "$osid" == +(1|2) ]]; then
		restorePartition "$part"
	elif [[ "$osid" == +([1-2]|[5-7]|9|50) ]]; then
		for part in $parts; do
			saveEBR "$part"
			partNum=${part:$diskLength}
			imgpart="$imagePath/d1p${partNum}.img*"
			sleep 2
			if [ ! -f $imgpart ]; then
				echo " * Partition File Missing: $imgpart"
				makeSwapSystem "${imagePath}/d1.original.swapuuids" "$part"
			else
				restorePartition "$part"
				restoreEBR "$part"
			fi
		done
	fi
	for part in $parts; do
		expandPartition "$part"
		fixWin7boot "$part"
	done
}

# TODO - Clean-up
function mpsPartDeploy() {
	parts=`getValidRestorePartitions $hd 1 $imagePath`
	diskLength=`expr length $hd`
	for part in $parts; do
		partNum=${part:$diskLength}
		if [ "$imgPartitionType" == "all" -o "$imgPartitionType" == "$partNum" ]; then
			restorePartition "$part" "1" "$imagePath" "$diskLength" "$imgPartitionType"
		else
			echo " * Skipping partition $partNum"
		fi
	done
	dots "Stopping FOG Status Reporter"
	kill -9 $statusReporter 2>/dev/null
	echo "Done"
	makeAllSwapSystems "$hd" "1" "$imagePath" "$imgPartitionType"
}

# TODO - Clean-up
function mpaPart() {
	disks=`fogpartinfo --list-devices 2>/dev/null`
	intDisk=1
	for disk in $disks; do
		parts=`getValidRestorePartitions $disk $intDisk $imagePath`
		diskLength=`expr length $disk`
		for part in $parts; do
			partNum=${part:$diskLength}
			if [ "$imgPartitionType" == "all" -o "$imgPartitionType" == "$partNum" ]; then
				echo " * Processing Partition: $part ($partNum)"
				restorePartition "$part" "$intDisk" "$imagePath" "$diskLength" "$imgPartitionType"
			else
				echo " * Skipping partition $partNum"
			fi
		done
		makeAllSwapSystems "$disk" "$intDisk" "$imagePath" "$imgPartitionType"
		intDisk=`expr $intDisk '+' 1`
	done
	dots "Stopping FOG Status Reporter"
	kill -9 $statusReporter 2>/dev/null
	echo "Done"
}

# TODO - Clean-up
function rawDiskDeploy() {
	restorePartition "$hd"
	dots "Stopping FOG Status Reporter"
	kill -9 $statusReporter 2>/dev/null
	echo "Done"
}

# TODO - Clean-up
function postDeployJobs() {
	if [ "$imgPartitionType" == "all" -o "$imgPartitionType" == "mbr" ]; then
		if [ "$gptcheck" == "yes" ]; then
			dots "Randomizing GUIDS"
			sgdisk -G $hd
			echo "Done"
			debugPause
		fi
	fi
	if [ -f "/images/postdownloadscripts/fog.postdownload" ]; then
		postdownpath="/images/postdownloadscripts/"
		. ${postdownpath}fog.postdownload
	fi
	if [ "$capone" != "1" ]; then
		if [[ "$osid" == +(1|[5-7]|9) ]]; then
			parts=`fogpartinfo --list-parts $hd 2>/dev/null`
			for part in $parts; do
				fstype=`fsTypeSetting $part`
				if [ "$fstype" = "ntfs" ]; then
					changeHostname
				fi
			done
		fi
		echo -e "\n * Updating Computer Database Status\n"
		cd /tmp
		queueinfo=""
		wget -q -O /tmp/co.txt "http://${web}service/Post_Stage3.php?mac=$mac&type=$type" &>/dev/null
		queueinfo=`cat co.txt`
		while [ "$queueinfo" != '##' ]; do
			echo "		* $queueinfo"
			rm co.txt
		wget -q -O /tmp/co.txt "http://${web}service/Post_Stage3.php?mac=$mac&type=$type" &>/dev/null
		queueinfo=`cat co.txt`
		sleep 5
		done
		echo -e "\n * Database Updated!\n"
		debugPause
	fi

}

### END FUNCTIONS

if [ ! -f "/images/.mntcheck" ]; then
	nfsFail  # NFS Mount failure message
elif [ -z "$img" ]; then
	handleError "No image specified to download"
else
	debugPause
	echo -e " * Deploying Image ${img} at ${imagePath}\n"
	dots "Looking for Hard Disks"
	getHardDisk
	echo "Done"
	if [ -z "$hd" ]; then
		handleError "HD is null, no hard disk found."
	fi
	debugPause

	# TODO BEGIN - Initialize the drive in a better fashion
	echo "Wiping $hd partition information"
	initHardDisk $hd
	# TODO END
	
	win7imgroot="$imagePath" # TODO - Find me a home or a grave

### BEGIN DEPLOYING IMAGE
	# First: Generates the partitions.  If singledisk resizeable, it generates
	# based on default normal values.
	# Otherwise it uses MBR/GPT to generate the partition table(s).
	# Second: It deploys the image to the client
	# Resizable Partition Image Type
	if [ "$imgType" == "n" ]; then
		adjstPartBuild
		adjstPartDeploy
	# Multiple Partition - Single Disk
	elif [ "$imgType" == "mps" ]; then
		mpsPartBuild
		mpsPartDeploy
	# Multiple Partition - All Disks
	elif [ "$imgType" == "mpa" ]; then
		mpaPartBuild
		mpaPartDeploy
	else
		rawDiskDeploy
	fi
	debugPause
### END DEPLOYING IMAGE

	postDeployJobs

	echo -e "\n * Task is completed, computer will now restart.\n"
	debugPause
fi
